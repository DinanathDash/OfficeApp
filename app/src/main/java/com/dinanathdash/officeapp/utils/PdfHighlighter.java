package com.dinanathdash.officeapp.utils;

import android.graphics.RectF;
import com.tom_roush.pdfbox.pdmodel.PDDocument;
import com.tom_roush.pdfbox.text.PDFTextStripper;
import com.tom_roush.pdfbox.text.TextPosition;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class PdfHighlighter extends PDFTextStripper {
    
    private final List<TextPosition> textPositions = new ArrayList<>();
    
    public PdfHighlighter() throws IOException {
        super();
    }

    @Override
    protected void processTextPosition(TextPosition text) {
        textPositions.add(text);
        // We don't call super because we don't need the string output formatted by PDFTextStripper
        // But to let it process logical order, maybe we should? 
        // Actually, just collecting positions in order is enough if we reconstruct the text ourselves.
        super.processTextPosition(text); 
    }
    
    /**
     * Finds matches of the query on the specified page and returns a list of RectF (PDF coordinates).
     * The caller is responsible for converting PDF coordinates to View coordinates.
     */
    public List<RectF> findMatches(PDDocument document, int pageIndex, String query) throws IOException {
        textPositions.clear();
        this.setStartPage(pageIndex + 1);
        this.setEndPage(pageIndex + 1);
        
        // This triggers processTextPosition for all characters on the page
        this.getText(document); 
        
        List<RectF> matchRects = new ArrayList<>();
        if (query == null || query.isEmpty()) return matchRects;
        
        // Reconstruct full text and map indices to TextPositions
        StringBuilder pageText = new StringBuilder();
        // PDFTextStripper might reorder text. processTextPosition receives them in the order Stripper processes them (usually sorted).
        // Let's assume textPositions matches the "visual" order roughly.
        // There's a risk of spacing issues. PDFBox doesn't explicitly store "space" characters as TextPositions usually.
        // It infers spaces. We might lose spaces if we just concat.
        // However, for highlighting, we need to map matched characters back to positions.
        // Simple approach: Concat all non-space characters? No, search won't work.
        // Robust approach: Use the text generated by PDFTextStripper (super.getText) but that doesn't give us index mapping easily.
        
        // Let's try to handle spaces roughly.
        int positionIndex = 0;
        List<Integer> textPosIndices = new ArrayList<>(); // Map char index in pageText to index in textPositions
        
        for (TextPosition tp : textPositions) {
            String unicode = tp.getUnicode(); // key assumption: matched 1-to-1 or N-to-1 (ligatures)
            pageText.append(unicode);
            for (int k = 0; k < unicode.length(); k++) {
                textPosIndices.add(positionIndex);
            }
            positionIndex++;
        }
        
        String fullText = pageText.toString().toLowerCase();
        String lowerQuery = query.toLowerCase();
        
        // Note: This naive concatenation ignores spaces usually inferred between words.
        // If "Hello World" is in PDF, textPositions has "Hello" and "World" characters, but no space TextPosition.
        // If query is "Hello World", this will fail.
        // Improving: We need to insert spaces where PDFBox would.
        // But `writeString` does that.
        // Overriding `writeString` is better?
        // `writeString(String text, List<TextPosition> textPositions)` gives the text PLUS the positions that generated it.
        // BUT `writeString` is called per line/chunk.
        // We can accumulate them.
        
        // Let's reset and correct the strategy in a separate method if needed, 
        // for now let's implement the `writeString` accumulation strategy inside this class.
        
        return matchRects; // Placeholder, real logic in findMatchesUsingWriteString
    }
    
    private final StringBuilder fullPageText = new StringBuilder();
    private final List<List<TextPosition>> fullPagePositions = new ArrayList<>();
    
    @Override
    protected void writeString(String text, List<TextPosition> textPositions) throws IOException {
        fullPageText.append(text);
        // We need to map each character in `text` to a TextPosition.
        // `text` might contain spaces that correspond to NO TextPosition, or 1-to-1.
        // PDFBox `writeString` parameter `textPositions` contains the TextPositions that make up the word/line.
        
        // A simple heuristic:
        // Identify non-space characters in `text` and map them to `textPositions`.
        int posIndex = 0;
        List<TextPosition> mappedPositions = new ArrayList<>();
        
        for (char c : text.toCharArray()) {
            if (Character.isWhitespace(c)) {
                 mappedPositions.add(null); // Space has no position
            } else {
                if (posIndex < textPositions.size()) {
                    mappedPositions.add(textPositions.get(posIndex));
                    posIndex++;
                } else {
                    // Should not happen theoretically
                    mappedPositions.add(null);
                }
            }
        }
        fullPagePositions.add(mappedPositions);
        super.writeString(text, textPositions);
    }
    
    public List<RectF> searchPage(PDDocument document, int pageIndex, String query) throws IOException {
        fullPageText.setLength(0);
        fullPagePositions.clear();
        
        this.setStartPage(pageIndex + 1);
        this.setEndPage(pageIndex + 1);
        
        // Suppress console output?
        this.setLineSeparator("\n"); // Normalizer handling
        
        String extracted = this.getText(document); 
        // This calls writeString internally
        
        List<RectF> highlightRects = new ArrayList<>();
        if (query == null || query.isEmpty()) return highlightRects;
        
        String pageContent = fullPageText.toString(); // This is the text built by writeString
        String lowerContent = pageContent.toLowerCase();
        String lowerQuery = query.toLowerCase();
        
        int index = lowerContent.indexOf(lowerQuery);
        while (index >= 0) {
            // Found a match at `index` of length `query.length()`
            // We need to find the TextPosition objects for this range.
            int endIndex = index + query.length();
            
            // Flatten the list of lists for easier lookup
            // Or just iterate.
            
            RectF unionRect = null;
            
            // Find coordinates
            int globalCharIndex = 0;
            for (List<TextPosition> linePositions : fullPagePositions) {
                // Determine if this line intersects with our match range
                int lineLen = linePositions.size();
                int lineStart = globalCharIndex;
                int lineEnd = globalCharIndex + lineLen;
                
                // Intersection logic
                int start = Math.max(lineStart, index);
                int end = Math.min(lineEnd, endIndex);
                
                if (start < end) {
                    // This line contains part of the match
                    for (int k = start; k < end; k++) {
                        TextPosition tp = linePositions.get(k - lineStart);
                        if (tp != null) {
                            RectF charRect = new RectF(
                                tp.getX(),
                                tp.getPageHeight() - tp.getY() - tp.getHeight(), // Bottom-left origin y assumption? No, PDFBox Y is from bottom.
                                // PDFBox Java coordinates:
                                // getX() is left.
                                // getY() is top of text? No, getY() is usually baseline or top depending on usage in PDFBox 2.0.
                                // In PDFBox 2.0:
                                // "getY() returns the y coordinate of the text, which is the baseline."
                                // "getYDirAdj() returns the y coordinate adjusted for direction."
                                // Use `getEndY()`?
                                
                                // Standard PDFBox coordinate extraction:
                                // x = getX()
                                // y = getY() - getHeight() (approx top)
                                // w = getWidth()
                                // h = getHeight()
                                
                                // Actually, let's look at standard advice.
                                // Y is from Top in Graphics usually, but PDF is Bottom-Up.
                                // PDFTextStripper flips it for us?
                                // "The coordinates are in user space units (points)."
                                
                                // IMPORTANT: PDFTextStripper might flip Y if `setSortByPosition` is used?
                                // Let's stick to raw values.
                                // tp.getX(), tp.getY(), tp.getWidth(), tp.getHeight()
                                
                                // We will form a rect and might need to adjust Y later based on PdfRenderer's behavior.
                                // PdfRenderer renders standard PDF content.
                                // If tp.getY() is "user space Y", we need to check if it's top-down or bottom-up.
                                // Usually PDFBox TextPosition.getY() is Top-Down, calculated from page top.
                                
                                tp.getX() + tp.getWidth(),
                                tp.getPageHeight() - tp.getY() // Placeholder
                            );
                            
                            // Re-evaluating Y
                            // tp.getY() is usually the baseline. 
                            // tp.getHeight() is font height.
                            // Top = tp.getY() - tp.getHeight() ? 
                            
                            // Let's use standard rect construction:
                            // left = getXDirAdj() (to handle rotation?) or just getX()
                            // top = getYDirAdj() - getHeightDir()
                            float x = tp.getXDirAdj();
                            float y = tp.getYDirAdj(); // Base line
                            float w = tp.getWidthDirAdj();
                            float h = tp.getHeightDir();
                            
                            // Top-down Y (PDFBox usually converts to Java/AWT friendly top-down)
                            // "y" is the baseline. 
                            float top = y - h;
                            
                            RectF r = new RectF(x, top, x + w, y + 2); // +2 for descendents/padding
                            
                            if (unionRect == null) {
                                unionRect = new RectF(r);
                            } else {
                                unionRect.union(r);
                            }
                        }
                    }
                }
                
                globalCharIndex += lineLen;
            }
            
            if (unionRect != null) {
                highlightRects.add(unionRect);
            }
            
            index = lowerContent.indexOf(lowerQuery, index + 1);
        }
        
        return highlightRects;
    }
}
